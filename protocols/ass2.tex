\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{VU Distributed Systems Technologies \\
       SS 2013 \\
       Assignment 2}
\author{Jakob Gruber, 0203440}

\begin{document}

\maketitle

% TODO: A peek under the cover
%       testScenario fails in ws
%       "A SOAP fault of type UnknownGridFault"
%       Complete job management bean
%       A way to bypass transaction rollback in audit interceptor

\section{Notes}

\subsection{Bean types}

There are two types of enterprise beans: \emph{Session}, which perform a task for
a client or may implement a web service; and \emph{Message-driven}, which acts
as a listener for a messaging type.

In this assignment, we only used \emph{Session} beans. These can be further divided
into:

\emph{Stateful}. This bean type has an internal state represented by its instance variables.
It is not shared between clients, and only exists within the scope of a client
conversation. When the session ends, the bean is removed. Stateful beans may not implement
a web service.

Appropriate, if: 

\begin{itemize}
    \item The bean’s state represents the interaction between the bean and a specific client.
    \item The bean needs to hold information about the client across method invocations.
    \item The bean mediates between the client and the other components of the application, presenting a simplified view to the client.
    \item Behind the scenes, the bean manages the work flow of several enterprise beans.
\end{itemize}

\emph{Stateless}. There is no state associated with this bean across method calls. However,
during a method call, a stateless bean may keep its state in instance variables.
Since all instances of this bean are equivalent, the server may pool instances and
assign them to clients as it sees fit. Stateless beans therefore offer better scalability
than other bean types. 

Appropriate, if: 

\begin{itemize}
    \item The bean’s state has no data for a specific client.
    \item In a single method invocation, the bean performs a generic task for all clients. For example, you might use a stateless session bean to send an email that confirms an online order.
    \item The bean implements a web service.
\end{itemize}

\emph{Singleton}. A singleton bean is instantiated once and kept for the lifetime of the server.
Every client accesses the same instance of the bean. State is maintained between invocations,
but not necessarily between crashes and shutdown.

Appropriate, if: 

\begin{itemize}
    \item State needs to be shared across the application.
    \item A single enterprise bean needs to be accessed by multiple threads concurrently.
    \item The application needs an enterprise bean to perform tasks upon application startup and shutdown.
    \item The bean implements a web service.
\end{itemize}

\subsection{EJB and SOAP Internals}

\begin{comment}
Study EJB and SOAP network traffic, discuss these in some detail.
\end{comment}

\subsection{Transparent Injection}

Java allows instrumentation using so-called agents, which are deployed as JAR files.
A command-line parameter called \verb|javaagent| points to the JAR file containing the agent, while
a parameter called \verb|Premain-Class| specifies which class to run to initialize the agent.

The \lstinline|premain()| method is executed by the JVM before the \lstinline|main()|
method of the actual program; within \lstinline|premain()|, the agent can hook itself
into the JVM systems as required. In this assignment, we registered an implementation
of the \lstinline|ClassFileTransformer| class, which is called whenever a new class
definition is loaded.

A \lstinline|ClassFileTransformer| can inspect and modify the entire definition of
a class before it is used by the actual program. We use this functionality to
inject a short code snippet into each constructor of each class annotated with \lstinline|@Component|,
which calls into \lstinline|IInjectionController.initialize()| to initialize itself
automatically.

This is accomplished using \verb|javassist|, a library for Java bytecode manipulation.
For each relevant class constructor, \verb|javassist| compiles our short source
code snippet into bytecode, and inserts it at the end of the constructor.

The modified bytecode is then returned by the \lstinline|ClassFileTransformer| and
used by the application.


\section{Theory}

\subsection{EJB Lifecycles (1 Point)}

\emph{
Explain the lifecycle of each bean type defined in the EJB 3.1 specification. What optimizations can the
EJB container perform for the respective type? Also think about typical use cases the respective bean
type provides to the developer.}

\subsection{Dependency Injection (2 Points)}

\emph{
Explain the way dependency injection is performed by the EJB container. What kind of resources may
be injected into a bean, and what are the different annotations that can be used?}

\subsection{Java Transaction API (2 Points)}

\emph{
The EJB architecture provides a mechanism for distributed transactions. Explain the two ways how
transactions can be defined. How is the concept of distributed transactions accomplished behind the
scenes, i.e. what tasks have to be performed by the EJB container?}

\subsection{Remoting Technologies (1 Point)}

\emph{Compare EJB remoting and Web services. When would you use one technology, and when the other? Is
one of them strictly superior? How do these technologies relate to other remoting technologies that you
might know from other lectures (for instance, Java RMI, CORBA, or even socket programming)?}

\end{document}
