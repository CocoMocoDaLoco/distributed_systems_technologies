\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{VU Distributed Systems Technologies \\
       SS 2013 \\
       Assignment 2}
\author{Jakob Gruber, 0203440}

\begin{document}

\maketitle

% TODO: A peek under the cover
%       testScenario fails in ws
%       "A SOAP fault of type UnknownGridFault"
%       Complete job management bean
%       A way to bypass transaction rollback in audit interceptor

\section{Notes}

\subsection{Bean types}

\subsection{EJB and SOAP Internals}

\begin{comment}
Study EJB and SOAP network traffic, discuss these in some detail.
\end{comment}

\subsection{Transparent Injection}

Java allows instrumentation using so-called agents, which are deployed as JAR files.
A command-line parameter called \verb|javaagent| points to the JAR file containing the agent, while
a parameter called \verb|Premain-Class| specifies which class to run to initialize the agent.

The \lstinline|premain()| method is executed by the JVM before the \lstinline|main()|
method of the actual program; within \lstinline|premain()|, the agent can hook itself
into the JVM systems as required. In this assignment, we registered an implementation
of the \lstinline|ClassFileTransformer| class, which is called whenever a new class
definition is loaded.

A \lstinline|ClassFileTransformer| can inspect and modify the entire definition of
a class before it is used by the actual program. We use this functionality to
inject a short code snippet into each constructor of each class annotated with \lstinline|@Component|,
which calls into \lstinline|IInjectionController.initialize()| to initialize itself
automatically.

This is accomplished using \verb|javassist|, a library for Java bytecode manipulation.
For each relevant class constructor, \verb|javassist| compiles our short source
code snippet into bytecode, and inserts it at the end of the constructor.

The modified bytecode is then returned by the \lstinline|ClassFileTransformer| and
used by the application.


\section{Theory}

\subsection{EJB Lifecycles (1 Point)}

\emph{
Explain the lifecycle of each bean type defined in the EJB 3.1 specification. What optimizations can the
EJB container perform for the respective type? Also think about typical use cases the respective bean
type provides to the developer.}

\subsection{Dependency Injection (2 Points)}

\emph{
Explain the way dependency injection is performed by the EJB container. What kind of resources may
be injected into a bean, and what are the different annotations that can be used?}

\subsection{Java Transaction API (2 Points)}

\emph{
The EJB architecture provides a mechanism for distributed transactions. Explain the two ways how
transactions can be defined. How is the concept of distributed transactions accomplished behind the
scenes, i.e. what tasks have to be performed by the EJB container?}

\subsection{Remoting Technologies (1 Point)}

\emph{Compare EJB remoting and Web services. When would you use one technology, and when the other? Is
one of them strictly superior? How do these technologies relate to other remoting technologies that you
might know from other lectures (for instance, Java RMI, CORBA, or even socket programming)?}

\end{document}
